# What Are Classes, Objects, and Methods? | Codecademy

# Objects as Parameters

Learn about best practices for sending an object as a constructor parameter.

We know that we can use constructor parameters to assign state to an object. Did you also know that we can send an object as a parameter to another object? In this article, weâ€™ll discuss how an object can be sent as a parameter as well as the best practices for accomplishing that.

### Using an Object as a Parameter

First, letâ€™s create a class called `Cupcake`:

```
class Cupcake {Â Â String flavor;Â Â boolean sprinkles;Â Â Â Â public Cupcake(String type, boolean hasSprinkles) {Â Â Â Â flavor =Â type;Â Â Â Â sprinkles =Â hasSprinkles;Â Â }}
```

Now, weâ€™ll create a class called `Bakery` whose constructor accepts an object of `Cupcake` as a parameter:

```
class Bakery {Â Â Cupcake bakeryCupcake;Â Â double price;Â Â String giveTotal;Â Â public Bakery(Cupcake cupcakeType, double priceOf) {Â Â Â Â bakeryCupcake =Â cupcakeType;Â Â Â Â price =Â priceOf;Â Â Â Â giveTotal =Â "The " +Â bakeryCupcake.flavor +Â " cupcake is â‚¬" +Â price;Â Â }}
```

Inside the `main()` method of the `Bakery` class, weâ€™ll create a new `Cupcake` object called `chocolateSprinkle`. Then, weâ€™ll create a new `Bakery` object, called `myBakery`, that takes the `chocolateSprinkle` object as a parameter:

```
public static void main(String[] args) {Â Â Cupcake chocolateSprinkle =Â new Cupcake("chocolate", true);Â Â // Add your code belowÂ Â Bakery myBakery =Â new Bakery(chocolateSprinkle, 3.25);Â Â System.out.println(myBakery.giveTotal); }
```

When we run this program, we get the following output:

```
The chocolate cupcake is â‚¬3.25
```

### Creating a Copy of an Object

If we use an object as a parameter for a constructor method, itâ€™s a good programming practice to not modify said object unless the situation requires it. If we do find ourselves needing to modify an object sent as a parameter, we should set the instance variable to hold a _copy_ of the referenced object instead of the original object.

Letâ€™s say we added the line `bakeryCupcake.flavor = "vanilla";`to our `Bakery` constructor that changes the `flavor` value of the `chocolateSprinkle` object to `"vanilla".`

```
public Bakery(Cupcake cupcakeType, double priceOf) {Â Â bakeryCupcake =Â cupcakeType;Â Â // change cupcake object flavor to vanillaÂ Â bakeryCupcake.flavor =Â "vanilla";Â Â price =Â priceOf;Â Â giveTotal =Â "The " +Â bakeryCupcake.flavor +Â " cupcake is â‚¬" +Â price;Â Â }
```

What happens to the state of our original `chocolateSprinkle` object after we call the constructor of our `Bakery` object?

Coding question

## Questions

Run the following code. Then, uncomment line 21. Feel free to change the current value on line 21. After, run the code again.

What happened to the state `flavor` for the object `chocolateSprinkle`? What about the state `flavor` for the parameter object `bakeryCupcake`?

### Code

CodeOutput

18

17

15

16

13

14

12

10

11

8

9

7

6

4

5

2

3

1

priceÂ =Â priceOf;

doubleÂ priceOf)Â {

bakeryCupcakeÂ =Â cupcakeType;

publicÂ Bakery(CupcakeÂ cupcakeType,

doubleÂ price;

StringÂ giveTotal;

CupcakeÂ bakeryCupcake;

classÂ BakeryÂ {

}

}

sprinklesÂ =Â hasSprinkles;

hasSprinkles)Â {

flavorÂ =Â type;

publicÂ Cupcake(StringÂ type,Â boolean

StringÂ flavor;

booleanÂ sprinkles;

classÂ CupcakeÂ {

Output:

Our object sent as a parameter has a flavor value of chocolate
Our original object has a flavor value of chocolate



ctrl + enter

ctrl + enter

RunLoading Complete

Copy file

Reset Workspace (ctrl+g)

Check answerAnswer Check Complete

ğŸ‘

You got it!

See how the `Bakery` constructor is impacting the `flavor` instance variable of our `chocolateSprinkle` object instead of only changing `bakeryCupcake`? Both of their `flavor` instance variables now have a value of `"vanilla"`.

Why did this happen? When an object is sent as an argument, the value sent to the parameter is a reference to the original object and not a copy of the original object; therefore, whenever we make a change to our parameter object, we are also making a change to our original object. Note that this doesnâ€™t happen with primitive values because the parameter value is initialized with a copy of the argument value.

To only change the value of the parameter object and not the original object, weâ€™ll discuss how to create a copy of an object.

One way to create a copy of an object is to make a copy constructor. The _copy constructor_ is an additional class constructor; remember, a class can have multiple constructors as long as each constructor has its own unique signature. Copy constructors create a copy of an object by taking in an object and setting the values of the new object to the same values of the parameter object.

For example, weâ€™ll add a copy constructor to the `Cupcake` class:

```
class Cupcake {Â Â String flavor;Â Â boolean sprinkles;Â Â // original constructorÂ Â public Cupcake(String type, boolean hasSprinkles) {Â Â Â Â flavor =Â type;Â Â Â Â sprinkles =Â hasSprinkles;Â Â }Â Â // copy constructorÂ Â public Cupcake(Cupcake copy) {Â Â Â Â flavor =Â copy.flavor;Â Â Â Â sprinkles =Â copy.sprinkles;Â Â }}
```

We now have a copy constructor, but in order to call it, we need to make a minor change to the `Bakery` constructor:

```
public Bakery(Cupcake cupcakeType, double priceOf) {Â Â // Create aÂ copy Cupcake objectÂ Â Cupcake copy =Â new Cupcake(cupcakeType);Â Â // set bakeryCupcake to hold value of object copyÂ Â bakeryCupcake =Â copy;Â Â price =Â priceOf;Â Â bakeryCupcake.flavor =Â "vanila";Â Â giveTotal =Â "The " +Â bakeryCupcake.flavor +Â " cupcake is â‚¬" +Â price;}
```

In our constructor, we created a new object, `copy`, that calls the copy constructor in order to create and store a copy of our parameter object `cupcakeType`. Then, we set our instance variable, `bakeryCupcake` to store the value of `copy`.

Now that we have a copy of the object, we donâ€™t have to worry about an object sent as a parameter to the `Bakery` class changing the state of our `Cupcake` objects, like `chocolateSprinkle`. By adding a copy constructor to our code, our output changes.

Coding question

## Questions

Take a look at the complete code. Feel free to play around with the program to get a better understanding of copy constructors and using objects as parameters.

### Code

CodeOutput

33

34

35

36

37

38

39

40

41

42

args)Â {

CupcakeÂ chocolateSprinkleÂ =Â new

Cupcake("chocolate",Â true);

BakeryÂ myBakeryÂ =Â newÂ Bakery

(chocolateSprinkle,Â 3.25);

//Â OutputÂ aÂ valueÂ ofÂ parameter

object

System.out.println("OurÂ object

sentÂ asÂ aÂ parameterÂ hasÂ aÂ flavor

ofÂ "Â Â +Â myBakery.bakeryCupcake.

flavor);

//Â OutputÂ aÂ valueÂ ofÂ original

object

System.out.println("OurÂ original

objectÂ hasÂ aÂ flavorÂ ofÂ "Â +

chocolateSprinkle.flavor);

}

}

Output:

Our object sent as a parameter has a flavor of vanila
Our original object has a flavor of chocolate



ctrl + enter

ctrl + enter

RunLoading Complete

Copy file

Reset Workspace (ctrl+g)

Check answerAnswer Check Complete

ğŸ‘

You got it!

We now see an output that reflects that even though we changed the value of an object sent as an argument value, the state of our original object `chocolateSprinkle` remains unchanged.

### Conclusion

Nice job reaching the end of this article. Letâ€™s recap what we learned:

-   Objects can be sent as a parameter to a constructor.
-   In order to avoid changing the state of the original object, itâ€™s best practice to create a copy of the object sent as a parameter.
-   One method of copying an object is creating a copy constructor that copies the attributes of an object into a new object.
