# Inheritance and Polymorphism | Codecademy

# The Object Superclass

Learn about the superclass of all classes in Java: the Object class!

### What is the Object Superclass?

We understand that, in inheritance, a subclass inherits all the qualities of a superclass. In terms of class hierarchy, a superclass sits above a subclass. There is a specific class that exists which sits at the very top of the class â€œfood chainâ€: the `Object` class. The `Object` class is part of the `java.lang` package and is the superclass of all other classes in the Java language. Every object we create in Java is a descendent of the `Object` class.

![A diagram showing the Object class above the String, Integer, and Math class](https://static-assets.codecademy.com/Paths/ap-computer-science/ObjectSuperclass/Object-Class-Diagram.png)

We know that in order to use inheritance, a subclass uses the keyword `extends` followed by the superclass name at the top of the class declaration. Imagine we had a superclass called `Plant` which contained a subclass called `Succulent`. If the class declaration of `Succulent` looks like `class Succulent extends Plant`, then `Succulent` is a subclass of `Plant`.

So how would `Object` be a superclass of `Plant` if our class declaration doesnâ€™t state `class Plant extends Object`? Java automatically continues to call the constructor of a superclass until it reaches the constructor of the `Object` class, even if the class doesnâ€™t use the `extends` keyword. This is why, in any class hierarchy, execution begins with the `Object` constructor.

Coding question

## Questions

Take a look at the following classes `Plant` and `Succulent`. Pay attention to the `main()` method of `Succulent` and try to predict what this program will output. Then, run the code. Was your prediction correct?

Each constructor calls the `super()` method. We can have the `Plant` constructor call `super()` so that the `Plant` class inherits the `Object` constructor without explicitly stating that `Plant` is a subclass of `Object`.

### Code

CodeOutput

```java
class Plant {
  String plantName;
  int plantHeight;

  public void waterPlant() {
    System.out.println("The " + plantName + " has been watered");
  }
  
  public Plant(String name, int height){
    /* We explicitly call the Object constructor even through we did not use the extends keyword
    */
    super();
    plantName = name;
    plantHeight = height;
    System.out.println("Plant constructor has been called");
  }
}

class Succulent extends Plant{
  public Succulent(String succulentName, int succulentHeight){
    super(succulentName, succulentHeight);
    System.out.println("Succulent constructor has been called");
  }
	public static void main(String[] args) {
     Succulent lithops = new Succulent("lithops", 1);
	}
}
```

Output:

Plant constructor has been called
Succulent constructor has been called
Â 

ctrl + enter

ctrl + enter

RunLoading Complete

Copy file

Reset Workspace (ctrl+g)

Check answerAnswer Check Complete

ğŸ‘

You got it!

#### Data Types of an Object

What is the data type of an object? This answer can change depending on whether the program is in compile-time or run-time. For example:

```
Plant echeveria =Â new Succulent();
```

During compile time, our `echeveria` object has a _declared type_ of `Plant`. Is this useful for any reason? Absolutely! Any methods within or inherited by the declared typeâ€™s class is determined for correctness when there is a non-static method call. For example:

```
Plant echeveria =Â new Succulent();// call aÂ non-existent method on our objectecheveria.goForARun();
```

In our above program, the line `echeveria.goForARun()` would cause a compile-time error since the `Plant` class doesnâ€™t have a `goForARun()` method. We can catch errors like this before we try to run our code.

Is there a situation where the object type could change? The answer is yes! During run-time, the _actual_ type of `echeveria` is `Succulent`. This is the object type we see after the assignment operator. If we called a non-static method on our object, Java would execute the method located in the class of the actual type. For example:

```
Plant echeveria =Â new Succulent();// call aÂ method of Succulent on our objectecheveria.changeSoil();
```

In the example above, the `changeSoil()` method would be called from the `Succulent` class.

Multiple choice

## Questions

What is the data type of `narwhal` during runtime?

### Code

```
Animal narwhal =Â new Whale("narwhal", 1200);
```

## Answer Choices

`Narwhal`

`Animal`

(Selected)Correct:

`Whale`

`1200`

ğŸ‘

Correct! During runtime, the actual type of `narwhal` is `Whale`.

### Useful Object Class Methods

The `Object` class contains several methods that can be used in our programs. For those taking the AP Computer Science A exam, the following `Object` class methods will be available in the [Java Quick Reference Guide](https://apstudents.collegeboard.org/ap/pdf/ap-computer-science-a-java-quick-reference_0.pdf):

#### String toString()

Normally when we try to print an object, the output shows the class name followed by an address:

```
class Succulent {Â Â String plantType;Â Â int plantHeight;Â Â Â Â public Succulent(String type, int height) {Â Â Â Â plantType =Â type;Â Â Â Â plantHeight =Â height;Â Â }}class Garden {Â Â public static void main(String[] args) {Â Â Â Â Â Succulent echeveria =Â new Succulent("echeveria", 7);Â Â Â Â Â System.out.println(echeveria);Â Â }}
```

The print statement in the `main()` method, would create an output like this:

```
Succulent@2f333739
```

Where did this mysterious String come from? The `toString()` method, [which weâ€™ve previously discussed](https://www.codecademy.com/courses/learn-java/lessons/learn-java-methods/exercises/the-tostring-method), defines what should be printed when we ask Java to print an object.

But we never wrote a `toString()` method for the `Succulent` class! So what method was called? Remember, all objects secretly inherit from the `Object` class, so if we donâ€™t override that method, weâ€™re just using `Object`â€˜s `toString()` method. If you take a look at [Objectâ€™s documentation](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#toString\(\)), you can see what that method is doing â€” if we use `Object`â€˜s `toString()` method, weâ€™ll print out the name of the class, the `@` sign, and then a number.

That being said, the `toString()` method is often overridden in subclasses to create a unique output for each individual class. To override a method, we must create a new method with the same method signature as the method we want to override. Therefore, to override the method `toString()`, we will create a non-static `toString()` method in our own class, like so:

```
class Succulent {Â Â String plantType;Â Â int plantHeight;;Â Â Â Â public Succulent(String type, int height) {Â Â Â Â plantType =Â type;Â Â Â Â plantHeight =Â height;Â Â }Â Â // override Object's toString() methodÂ Â public String toString(){Â Â Â Â return "This is a(n) " +Â plantType +Â " type succulent that is " +Â plantHeight +Â " inches tall.";Â Â } }class Garden {Â Â public static void main(String[] args) {Â Â Â Â Â Succulent echeveria =Â new Succulent("echeveria", 7);Â Â Â Â Â System.out.println(echeveria);Â Â }}
```

By adding in our own `toString()` method, the statement `System.out.println(echeveria);` outputs the following:

```
This is a(n) echeveria type succulent that is 7Â inches tall.
```

In fact, you can see the `Object` `toString()` method being overridden in other built-in Java classes. Take a look at the documentation for the [Integer class](https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#toString\(\)). Then consider the code block below.

```
Integer numLeaves =Â 3;System.out.println(numLeaves); // Prints 3Â as Integer value
```

Why do we see the number `3` rather than the memory address?

Coding question

## Questions

Run the following program. What is the output?

What happens when lines 11-15 get uncommented and the program is run again?

### Code

CodeOutput

```java
class Whale {
  String whaleSpecies;
  int whaleWeight;
  
  public Whale(String name, int weight) {
    whaleSpecies = name;
    whaleWeight = weight;
  }

  // Uncomment the method below
  
  public String toString(){
    return "This is a " + whaleSpecies + " whale which weighs about " + whaleWeight + " pounds.";
  }
  
}

class WhaleWatching {
  public static void main(String[] args) {
    Whale whale1 = new Whale("narwhal", 2100);
    System.out.println(whale1);
  }
}
```

Output:

This is a narwhal whale which weighs about 2100 pounds.
This is a narwhal whale which weighs about 2100 pounds.
This is a narwhal whale which weighs about 2100 pounds.
Â 

ctrl + enter

ctrl + enter

RunLoading Complete

Copy file

Reset Workspace (ctrl+g)

Check answerAnswer Check Complete

ğŸ‘

You got it!

### Boolean equals(Object other)

The `equals()` method is used to compare two objects. The method returns `true` if the objects are equal and `false` otherwise. What do we mean by â€œequalâ€? Well, luckily, we get to decide ourselves! By default, objects will use the `Object` `equals()` method. This method is a bit hard to understand â€” take a look at [the documentation](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals\(java.lang.Object\)). Luckily, just like with `toString()`, the `equals()` method from the `Object` class is often overwritten. Take a look at the [String documentation](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#equals\(java.lang.Object\)) to see how the `String` class overrides `equals()` â€” `String`s are equal if they have the same sequence of characters.

```
// Declare 3Â String objectsString a =Â new String("Dracaena");String b =Â new String("Haworthia");String c =Â new String("Haworthia");Â Â Â Â Â Â Â Â Â Â // Compare two objects that are not equalSystem.out.println(a.equals(b)); // Prints: false// Compare two objects that are equalSystem.out.println(b.equals(c)); // Prints: true
```

We can also override the `Object` `equal()` method in our own classes:

```
class Succulent {Â Â String plantType;Â Â int plantHeight;Â Â Â Â public Succulent(String type, int height) {Â Â Â Â plantType =Â type;Â Â Â Â plantHeight =Â height;Â Â }Â Â // override the equals() methodÂ Â public boolean equals(Succulent otherPlant) {Â Â Â Â if (!plantType.equals(otherPlant.plantType)) {Â Â Â Â Â Â System.out.println("Succulent names are not equal.");Â Â Â Â Â Â return false;Â Â Â Â }Â Â Â Â else if (plantHeight != otherPlant.plantHeight) {Â Â Â Â Â Â System.out.println("Succulent heights are not equal");Â Â Â Â Â Â return false;Â Â Â Â }Â Â Â Â else {Â Â Â Â Â Â System.out.println("Succulents are equal.");Â Â Â Â Â Â return true;Â Â Â Â }Â Â }}class Garden {Â Â public static void main(String[] args) {Â Â Â Â Â // Create three Succulent objectsÂ Â Â Â Â Succulent plant1 =Â new Succulent("echeveria", 7);Â Â Â Â Â Succulent plant2 =Â new Succulent("haworthia", 4);Â Â Â Â Â Succulent plant3 =Â new Succulent("echeveria", 7);Â Â Â Â Â // Compare two objects that are not equalÂ Â Â Â Â System.out.println(plant1.equals(plant2));Â Â Â Â Â // Compare two objects that are equalÂ Â Â Â Â System.out.println(plant1.equals(plant3));Â Â }}
```

In the program above, we created our own unique `equals()` method. If there are any differences between the two objectsâ€™ attributes, the method prints what value causes the two objects to not be equal and then returns `false`; if the objects are equal, the method prints `"Succulents are equal"` and then returns `true`.

Note the condition in the `if` statement: `!plantType.equals(otherPlant.plantType)`. How can we call an `equals()` method inside our own `equals()` method? `plantType` is a `String`; when we call `equals()` on a `String` value, the `equals()` method is being called from the `String` class, which has its own overridden `equals()` method.

If we run this program, we will get the following output:

```
Succulent names are not equal.falseSucculents are equal.true
```

Coding question

## Questions

Run the code below. When we call the `Object` classâ€™ `equals()` method, our program outputs two `false` values.

Weâ€™re going to override the `Object` classâ€™ `equals()` method. Create an `equals()` method that takes in an object of `Whale` and returns a boolean value.

The method should return `true` only if both objectsâ€™ `whaleSpecies` attribute is equal. Otherwise, the function should return `false`.

### Code

CodeOutput
```java
class Whale {
  String whaleSpecies;
  int whaleWeight;
  
  public Whale(String name, int weight) {
    whaleSpecies = name;
    whaleWeight = weight;
  }

  // Add the equals() method below
  public boolean equals(Whale other) {
    return this.whaleSpecies.equals(other.whaleSpecies) && this.whaleWeight==other.whaleWeight;
  }


  public static void main(String[] args) {
    Whale whale1 = new Whale("narwhal", 2100);
    Whale whale2 = new Whale("narwhal", 2100);
    Whale whale3 = new Whale("beluga", 3000);
    System.out.println(whale1.equals(whale2));
    System.out.println(whale1.equals(whale3));
  }

}
```

Output:

true
false
Â 

ctrl + enter

ctrl + enter

RunLoading Complete

Copy file

Reset Workspace (ctrl+g)

View solution

View solution

Check answerAnswer Check Complete

ğŸ‘

You got it!

### Conclusion

Great job reaching the end of this article. We discovered a lot about the `Object` superclass. Letâ€™s recap what we learned:

-   The `Object` class is the superclass of all other Java classes.
-   The `Object` class constructor will be called automatically if it is not called explicitly.
-   The data type of an object can be different during compile time vs runtime.
-   The `Object` class contains the methods `toString()` and `equals()`; they can be overridden for class-specific implementations.

## Embedded Content

---

