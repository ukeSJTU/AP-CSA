# Searching and Sorting | Codecademy

# Binary Search: Iteratively and Recursively

In this interactive article, we will implement a binary search with iterative and recursive implementations.

Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you’ve narrowed down the possible locations to just one.

With a sorted data-set, we can take advantage of the ordering to make a sort which is more efficient than going element by element, such as linear sort. Let’s say you were guessing a number between 1 - 100 and you had four guesses available. In response to your guesses, you would receive feedback if the number is “higher” or “lower”.

What if you began with a guess of 1? You could possibly be right. However, if you are wrong the only feedback you will get is “higher”. You are now guessing between 2 - 100 with only three guesses left. You could guess 2. Again, you could be right but if you are wrong the only feedback you get is “higher”. You are now guessing between 3 - 100 with only two guesses left. There has to be a better way!

There is — binary search. For our first pick, we could pick a _better_ number between 1 and 100 — we could pick 50. Suppose we are wrong but receive the feedback, “higher”. We are now guessing between 51 - 100. We decide to pick a number in the middle again, 75. We are wrong again but get the feedback, “lower”. With 2 guesses left we are now guessing a range of 51 - 74. We know we are getting much closer with only a couple guesses!

It’s important to underscore that binary search only works on list that are already sorted. If we had an unsorted list, a response like “higher” or “lower” wouldn’t help because we wouldn’t know which side of the list to look at once getting that response.

**Binary Implementation**

Binary search requires a sorted data-set. We then take the following steps:

Step 1. Check the middle value of the dataset.

-   If this value matches our target we can return the index.

Step 2. If the middle value is less than our target.

-   Start at step 1 using the right half of the list.

Step 3. If the middle value is greater than our target.

-   Start at step 1 using the left half of the list.

We eventually run out of values in the list, or find the target value.

**Example**

To find the number `27` in the following list `[3, 4, 12, 17, 22, 27, 28, 36, 50]`, we would:

Check if the middle value, `22`, is equal to the target number `27`:

-   22 != 27

Because `27 > 22` we will now look at the right half of the array:

-   `[27, 28, 36, 50]`

Check if the middle value, `28`, is equal to the target number `27`:

-   27 != 28

Because `27 < 28` we will now look at the item(s) to the left:

-   `[27]`

Check if the middle value, `27`, is equal to the target number `27`:

-   `27 = 27`

Return `27`

Note that when we find the “middle element” sometimes that’s tricky because there could be an even number of elements. In that case, we’ll take the smaller of the two middle elements.

<iframe src="https://static-assets.codecademy.com/Paths/ap-computer-science/BinarySearch/binarySearchGif/interactive-gif-index.html" height="650" class="styles_iframe__pz8Vb"></iframe>

Let’s talk about how to do this recursively and iteratively! What is the difference between the two approaches?:

-   Iteratively: We keep iterating through the same set of instructions.
-   Recursively: We solve a problem by having a method call itself.

**Recursive Approach**

There is an old computer science joke that “to understand recursions, one must first understand recursion.” Let’s first take a look at a recursive solution to help us understand this approach.

Recursion is a powerful tool for solving problems that require the execution of an action multiple times until a condition, or _**base case**_, is met. For many problems, a recursive solution will result in fewer lines of code and will be easier to comprehend than a solution that uses a for or while loop. In programming, recursion means a method definition will include an invocation of the method within its own body. The _**recursive step**_ is calling the method with arguments which bring us closer to the base case.

**Implementation of Recursion Steps in Java**

Our `binarySearch()` method will accept the following parameters:  
`arr` - our array argument passed in  
`left` - the starting index of our array  
`right` - the index of the final element in our array  
`target` - the value we are searching the array for

```
class BinarySearch{  public static int binarySearch(int[] arr, int left, int right, int target)  {// implement steps here   }   public static void main(String[] args)  {    int[] arr = { 2, 5, 6, 8, 9, 10 };    int target = 8;     int left = 0;    int right = arr.length - 1;     int index = binarySearch(arr, left, right, target);    if (index != -1) {      System.out.println("Element found at index " + index);    } else {      System.out.println("Element not found in the array");    }  }}
```

There are many possible ways of implementing this algorithm with recursion in Java. We’ll outline a basic approach here and then walk through it step-by-step.

Step 1. Create a variable `mid` type int, that we will use to pick the midpoint index of our array.

Step 2. Create a base case, a scenario where we’re stopping the recursion, that checks if our `target` is equal to the value of our array at `mid`. If it is, return `mid`. The `main()` method will print a message that says, “Element found at index \_”.

Step 3. Create 2 recursive conditions:

-   Check if `target` is less than the value of our input array at index `mid`. If true, return the value of recursively calling `binarySearch()`, passing in values to search the left half of our array.
-   Check if `target` is greater than the value of array at index `mid`. If true, return the value of recursively calling `binarySearch()`, passing in values to search the right half of our array.

Step 4. Create another base case that checks if our search space has been exhausted. When this happens, we will return a `-1`. This will trigger the printing of the message from our `main()` method, “Element not found in the array.”

**Steps One & Two: Defining the Midpoint and Returning the Target Index if Found**

We’ll create an `int`, `mid`, that we will use to check if our `target` is equal to `mid`. To get the value of `mid` we will use a formula of `(left + right) / 2`. Note that when dividing `int`s, the result will be rounded down:

```
5 / 2; // 2
```

Now that we’ve found our midpoint, we can see if it’s equal to our target value. If it is, we will return `mid`. Our main method will then print out “Element found at index \_”, and fill in the value for `mid`.

Fill in the blank

## Questions

Fill in the `binarySearch()` function below to set the value for `mid` and fulfill the base condition that the target value is found.

### Code

```
class BinarySearch{  public static int binarySearch(int[] arr, int left, int right, int target)  {    int mid = (left + right) / 2;    // Base condition (target value is found)    if (target == arr[mid]) {      return mid;    }      }  public static void main(String[] args)  {    int[] arr = { 2, 5, 6, 8, 9, 10 };    int target = 8;     int left = 0;    int right = arr.length - 1;     int index = binarySearch(arr, left, right, target);   if (index != -1) {      System.out.println("Element found at index " + index);    } else {      System.out.println("Element not found in the array");    }  }}
```

## Answer Choices

Click or drag and drop to fill in the blank

👏

You got it!

**Step Three: Recursive Cases**

In recursion, the recursive case is the condition under which a method calls itself.

Now it’s time to create our recursive cases:

-   If our `target` value is less than our array value at the index of `mid`, return the call of `binarySearch()` and pass in `arr`, a value search the left half of the array, a value of one less than `mid` and `target`. We no longer need the right half of our array to search.
-   If our `target` value is greater than our array value at the index of `mid`, return the call of `binarySearch()` and pass in `arr`, a value of one greater than the `mid`, and a value for right half of the list and `target`. We no longer need the left half of our array to search.

Complete the `binarySearch()` method.

Fill in the blank

## Questions

Complete the `binarySearch()` function.

### Code

```
class Main{  public static int binarySearch(int[] arr, int left, int right, int target)  {       int mid = left + (right - left) / 2;    // Base condition (key value is found)    if (target == arr[mid]) {      return mid;    }    // discard all elements in the right search space    // including the mid element    if (target < arr[mid]) {      return binarySearch(arr, left, mid - 1, target);    }    // discard all elements in the left search space    // including the mid element     if (target > arr[mid]) {      return binarySearch(arr, mid + 1, right, target);    }  }  public static void main(String[] args)  {    int[] arr = { 2, 5, 6, 8, 9, 10 };    int target = 8;     int left = 0;    int right = arr.length - 1;     int index = binarySearch(arr, left, right, target);   if (index != -1) {      System.out.println("Element found at index " + index);    } else {      System.out.println("Element not found in the array");    }  }}
```

## Answer Choices

Click or drag and drop to fill in the blank

👏

You got it!

**Step Four: Base Case**

Our base case will run if the element is not in our array. We determine this by checking if our value for `left` is greater than our value for `right`. This means that we have exhausted our search. If so, return a value of `-1`.

Fill in the blank

## Questions

Fill in the code.

### Code

```
class BinarySearch{  public static int binarySearch(int[] arr, int left, int right, int target)  {    if (left > right) {      return -1;    }        int mid = left + (right - left) / 2;    // Base condition (key value is found)    if (target == arr[mid]) {      return mid;    }    // discard all elements in the right search space    // including the mid element    if (target < arr[mid]) {      return binarySearch(arr, left, mid - 1, target);    }    // discard all elements in the left search space    // including the mid element     if (target > arr[mid]) {      return binarySearch(arr, mid + 1, right, target);    }  }  public static void main(String[] args)  {    int[] arr = { 2, 5, 6, 8, 9, 10 };    int target = 8;     int left = 0;    int right = arr.length - 1;     int index = binarySearch(arr, left, right, target);    if (index != -1) {      System.out.println("Element found at index " + index);    } else {      System.out.println("Element not found in the array");    }  }}
```

## Answer Choices

Click or drag and drop to fill in the blank

👏

You got it!

Great job! We have create a `binarySearch()` method that uses recursion! Remember, recursion is a computational approach where a method calls itself from within its body. Programmers use recursion when they need to perform the same action multiple times in a row until it reaches a predefined stopping point, also known as a base case.

**Implementing Binary Search with Iterative Steps in Java**

Now, let’s look at the iterative implementation. Remember, an iterative solution means that we keep iterating through the same set of instructions.

Our `binarySearch()` method will accept the following parameters:  
`arr` - our array argument passed in  
`target` - the value we are searching the array for

```
class BinarySearch{  public static int binarySearch(int[] arr, int target)  {    // write code here    }  public static void main(String[] args)  {    int[] arr = { 2, 5, 6, 8, 9, 10 };    int target = 6;    int index = binarySearch(arr, target);    if (index != -1) {      System.out.println("Element found at index " + index);     } else {     System.out.println("Element not found in the array");     }  } }
```

There are many possible ways of implementing this algorithm iteratively in Java. We’ll outline a basic approach here and then walk through it step-by-step.

1.  Create variables that hold the index value of the start and end of an array. These values will be similar to our `left` and `right` values for our recursive solution.
2.  We will create a `while` loop that will continue to run as long as the starting index is less than or equal to the ending index, meaning that we still have at least one element. If our condition breaks, outside of our `while` loop we will return `-1`, which will trigger the printing of “Element not found in the array” from the `main()` method. This is similar to the base case in the recursive solution. We want to keep going as long as the left and right pointers don’t pass each other.
3.  Inside our `while` loop, create a value `mid` that will contain the index of the midpoint of the array. We are going to use this to check the value of our array at this index and compare the value with `target` to see if we have found our value. If we have, we will return `mid`, which will trigger the printing of “Found the element at index \_” from the `main()` method. This is similar to our base case in the recursive solution — we can stop if we’ve found the correct answer.
4.  Next, we will create two more conditionals if `target` is greater or less than our array at `mid`:

-   If `target` is higher than the midpoint, `mid`, we will set `right`, the end of our new list, to our midpoint position minus 1. This discards the right half of the list.
-   If `target` is lower than `mid`, then we will want to set `left`, to the midpoint position plus 1, discarding the left hand side of the list.
-   These steps are similar to our recursive cases from the recursive solution. We haven’t found our value yet, so we want to keep looking at either the left half or right half of the list. Rather than calling our method with new values for `left` or `right`, we’re going to reset the values of `left` and `right` and do another iteration of our loop.

**Step One: Capture Index Values for Start and End of Array**

Our first step will be to create variables `left` and `right` of type `int`. We want to initially set these to capture the index of the first element in the array and the index of the last element of the array. These values will later be changed in our loop in the cases that our `target` is greater or lesser than the value at the midpoint of our array.

Fill in the blank

## Questions

Fill in the `binarySearch()` function below.

### Code

```
class BinarySearch{  public static int binarySearch(int[] arr, int target)  {     int left = 0;      int right = array.length - 1;   }   public static void main(String[] args)  {    int[] arr = { 2, 5, 6, 8, 9, 10 };    int target = 6;    int index = binarySearch(arr, target);    if (index != -1) {    System.out.println("Element found at index " + index);     } else {    System.out.println("Element not found in the array");     }  }}
```

## Answer Choices

Click or drag and drop to fill in the blank

👏

You got it!

**Step Two: Create a While Loop and Print Message if Target Value Not Found**

Next, we want to create a `while` loop that is going to run as long as `left` is less than or equal to `right`. This means that our list still contains at least one element. If our condition breaks it means that our element was not found. Outside of the `while` loop return a value of `-1` that will print a message of “Did not find the value.”, from our `main()` method.

Fill in the blank

## Questions

Fill in the code.

### Code

```
class BinarySearch{  public static int binarySearch(int[] arr, int target)  {     int left = 0;      int right = array.length - 1;    while (left <= right)    {        }    return -1;  }   public static void main(String[] args)  {    int[] arr = { 2, 5, 6, 8, 9, 10 };    int target = 6;    int index = binarySearch(arr, target);    if (index != -1) {    System.out.println("Element found at index " + index);     } else {    System.out.println("Element not found in the array");     }  }}
```

## Answer Choices

Click or drag and drop to fill in the blank

👏

You got it!

**Step Three: Check if Midpoint Element is the Target**

Next, we’ll create an `int` named `mid` that we will use to check if our `target` is equal to `mid`. To get the value of `mid` we will use a formula of `(left + right) / 2`.

Next, we’ll check if our `target` is equal to our input array at the index of `mid`. If it is, this will trigger the printing of a message from the `main()` method, “Element found at index \_”, and return `mid`.

Fill in the blank

## Questions

Fill in the blanks of the `binarySearch()` function below to set the value for `mid` and the condition that returns the value of `mid` if `target` is equal to our array at index `mid`.

### Code

```
class BinarySearch{  public static int binarySearch(int[] arr, int target)  {     int left = 0;      int right = array.length - 1;    while (left <= right)    {            int mid = (left + right) / 2;      if (target == array[mid]) {        return mid;      }    }    return -1;  }     public static void main(String[] args)  {    int[] arr = { 2, 5, 6, 8, 9, 10 };    int target = 6;    int index = binarySearch(arr, target);    if (index != -1) {    System.out.println("Element found at index " + index);     } else {    System.out.println("Element not found in the array");     }  }}
```

## Answer Choices

Click or drag and drop to fill in the blank

👏

You got it!

**Step Four: Choose the Left or Right Half of the List**

In our last step we will create conditionals for the case that `target` is greater or less than `mid`.

-   Check if `target` is _less_ than the value found at the index `mid` of our array. If so, set the `right` endpoint of our array to one less than the midpoint, `mid`.
-   Check if `target` is _more_ than the value found at the index `mid` of our array. If so, set the left starting point of our array to one greater than the midpoint, `mid`.

Fill in the blank

## Questions

Fill in the code.

### Code

```
class BinarySearch{  public static int binarySearch(int[] arr, int target)  {     int left = 0;      int right = array.length - 1;    while (left <= right)    {            int mid = (left + right) / 2;      if (target == array[mid]) {        return mid;      }     if (target < arr[mid]) {        right = mid - 1;      }      if (target > arr[mid]) {        left = mid + 1;      }    }    return -1;  }    public static void main(String[] args)  {    int[] arr = { 2, 5, 6, 8, 9, 10 };    int target = 6;    int index = binarySearch(arr, target);    if (index != -1) {    System.out.println("Element found at index " + index);     } else {    System.out.println("Element not found in the array");     }  }}
```

## Answer Choices

Click or drag and drop to fill in the blank

👏

You got it!

**Conclusion**

Is there a benefit to choosing one approach over the other? In the end, there isn’t a huge performance difference between the two implementations of the algorithm. Both will have the same time complexity `O(log(n))`, but they will differ in terms of space usage. The recursive version has a space complexity of `O(log N)` while the slight nod goes to the iterative version which has a space complexity of `O(1)`.

This is an excellent algorithm to try to wrap your head around recursion. Compare the steps in the recursive solution to the steps in the iterative solution to find similarities.

## Embedded Content
