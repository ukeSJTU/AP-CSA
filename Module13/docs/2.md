# Algorithmic Complexity | Codecademy

# Asymptotic Notation: Conceptual: What is Asymptotic Notation?

## Narrative and Instructions

Learn

Asymptotic Notation: Conceptual

### What is Asymptotic Notation?

6 min

Cheetahs. Ferraris. Life. All are fast, but how do you know which one is the fastest? You can measure a cheetah’s and a Ferrari’s speed with a speedometer. You can measure life with years and months.

But what about computer programs? In fact, you _can_ time a computer program, but different computers run at different speeds. For example, a program that takes 12 nanoseconds on one computer could take 45 milliseconds on another. Therefore, we need a more general way to gauge a program’s runtime. We do this with _Asymptotic Notation_.

Instead of timing a program, through asymptotic notation, we can calculate a program’s runtime by looking at how many instructions the computer has to perform based on the size of the program’s input: N.

For instance, a program that has input of size N may tell the computer to run 5N2+3N+2 instructions. (We will get into how we get this kind of expression in future exercises.) Nevertheless, this is still a fairly messy and large expression. For asymptotic notation, we drop all of our constants (the numbers) because as N becomes extremely large, the constants will make minute differences. After changing our constants, we have N2+N. If we take each of these terms in the expression and graph them, we see that the N2 term grows faster than the N term.

![alt text](https://content.codecademy.com/programs/cs-path/asymptotic%20notation/conceptual/runtimes%20compare.png)

For example, when N is 1000:

-   the N2 term is 1,000,000
-   the N term is 1,000

As you can see, the N2 term is much more significant than the N term. When N is larger than 1000, the difference becomes even more significant. Because the difference is so enormous, we don’t even need to consider the N term when calculating the runtime. Thus, for this program, we would describe the runtime in terms of N2. There are three different ways we could describe the runtime of this program: big Theta or Θ(N2), big O or O(N2), big Omega or Ω(N2). The difference between the three and when to use which one will be detailed in the next exercises.

You may see the term **execution count** used in evaluating algorithms. Execution count is more precise than Big O notation. The following method, `addUpTo()`, depending on how we count the number of operations, can be as low as 2N or as high as 5N + 2

```
public class Main() {   void int addUpTo(int n) {    int total = 0;    for (int i = 1; i <= n; i++) {      total += i;    }  return total;  } }
```

Determining execution count can increase in difficulty as our algorithms become even more sophisticated!

But regardless of the execution count, the number of operations grows roughly proportionally with n. If n doubles, the number of operations will also roughly double.

Big O Notation is a way to formalize fuzzy counting. It allows us to talk formally about how the runtime of an algorithm grows as the inputs grow. As we will see, Big O doesn’t focus on the details, only the trends

Instructions

Play the video to learn about asymptotic notation in a more visual setting.

Community Support

Still have questions? Get help from the [Codecademy community](https://community.codecademy.com/c/start-here/).

## Video

<iframe frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" title="Asymptotic Notation" width="100%" height="100%" src="https://www.youtube.com/embed/ZPLaE0HOR3M?autoplay=0&amp;mute=0&amp;controls=1&amp;origin=https%3A%2F%2Fwww.codecademy.com&amp;playsinline=1&amp;showinfo=0&amp;rel=0&amp;iv_load_policy=3&amp;modestbranding=1&amp;color=white&amp;enablejsapi=1&amp;widgetid=1&amp;forigin=https%3A%2F%2Fwww.codecademy.com%2Fpaths%2Fap-computer-science-a%2Ftracks%2Fapcs-algorithms%2Fmodules%2Fapcs-algorithmic-complexity%2Flessons%2Fasymptotic-notation-conceptual%2Fexercises%2Fintro&amp;aoriginsup=1&amp;gporigin=https%3A%2F%2Fwww.codecademy.com%2Fpaths%2Fap-computer-science-a%2Ftracks%2Fapcs-algorithms%2Fmodules%2Fapcs-algorithmic-complexity%2Farticles%2Fcspath-why-asymptotic-notation&amp;vf=6" id="widget2"></iframe>

TODO: 需要观看视频并且整理内容。
视频中介绍了渐进符号如何通过函数输入的大小来描述函数的运行时间，强调了在渐进分析中常数项和非主导项对于大型输入变得不重要，并指出了 Big O、Theta 和 Omega 符号在表示运行时间时的不同用法。
Detailed Summary for [Asymptotic Notation

不公开](https://www.youtube.com/watch?v=ZPLaE0HOR3M) by [Monica](https://monica.im)

[00:00](https://www.youtube.com/watch?v=ZPLaE0HOR3M&t=0.719) 本视频介绍了渐近符号的基本概念及其在描述函数运行时间中的应用。

-   视频开始介绍渐近符号的定义及其重要性。}
-   讨论了仅通过计时来描述函数运行时间的局限性。}
-   通过渐近符号，可以根据函数输入的大小来描述运行时间。}
-   举例说明了一个输入大小为 n 的函数及其运行时间的表达方式。}

[01:55](https://www.youtube.com/watch?v=ZPLaE0HOR3M&t=115.23) 本段视频介绍了渐近符号的概念，重点讨论了不同函数在运行时间上的增长速率，特别是 n² 和 n 之间的关系。

-   介绍了一种更简洁的方式来描述函数的运行时间。}
-   通过图表展示 n² 和 n 的增长趋势。}
-   随着 n 的增大，n² 的增长速度远快于 n。}
-   举例说明当 n 为 100 时，n² 的值远大于 n。}
-   在 n 足够大时，n 的影响几乎可以忽略不计，n² 成为主导项。}

## Embedded Content

# Algorithmic Complexity | Codecademy

# Asymptotic Notation: Conceptual: Big Theta (Θ)

## Narrative and Instructions

Learn

Asymptotic Notation: Conceptual

### Big Theta (Θ)

5 min

The first subtype of asymptotic notation we will explore is big Theta (denoted by Θ). We use big Theta when a program has only one case in terms of runtime. But what exactly does that mean? Take a look at the pseudocode for a function that prints the values in a list below:

```
Function with input that is a list of size N:   For each value in list:    Print the value
```

The number of instructions the computer has to perform is based on how many iterations the loop will do because if the loop does more iterations, then the computer will perform instructions. Now, let’s see how many iterations the loop will do dependent on the value of N.

Size of List

–vs.–

Number of Iterations

1

1

2

2

3

3

**.**

**.**

**.**

**.**

**.**

**.**

**.**

**.**

**.**

**.**

N

N

As we can see in every case, with a list of size N, the program has a runtime of N because the program has to print a value N times. Thus, we would say the runtime is Θ(N).

Let’s look at a more complicated example. In the following pseudocode program, the function takes in an integer, N, and counts the number of times it takes for N to be divided by 2 until N reaches 1.

```
Function that has integer input N:    Set a count variable to 0    Loop while N is not equal to 1:        Increment count        N = N/2    Return count
```

Now, let’s see how many iterations the loop will perform based on N.

N

–vs.–

Number of Iterations

1

0

**.**

**.**

**.**

**.**

**.**

**.**

2

1

**.**

**.**

**.**

**.**

**.**

**.**

4

2

**.**

**.**

**.**

**.**

**.**

**.**

8

3

**.**

**.**

**.**

**.**

**.**

**.**

16

4

**.**

**.**

**.**

**.**

**.**

**.**

N

log2N

As we can see, in every case, with an integer N, the loop will iterate log2(N) times. However, because we drop constants in asymptotic notation, we would say that the runtime of this program is Θ(log N).

But what happens when there are multiple runtime cases for a single program? We will learn about that in a future exercise.

Instructions

Play the video to go through an example of finding the big Theta runtime of a function.

Community Support

Still have questions? Get help from the [Codecademy community](https://community.codecademy.com/c/start-here/).

## Video

## Embedded Content

---

# Algorithmic Complexity | Codecademy

# Asymptotic Notation: Conceptual: Common Runtimes

## Narrative and Instructions

Learn

Asymptotic Notation: Conceptual

### Common Runtimes

2 min

Before we delve into the multiple runtime cases, let’s see the different common runtimes a program could have. Below is a list of common runtimes that run from fastest to slowest.

-   **Θ(1)**. This is _constant_ runtime. This is the runtime when a program will always do the same thing regardless of the input. For instance, a program that only prints “hello, world” runs in `Θ(1)` because the program will always just print “hello, world”.
-   **Θ(log N)**. This is _logarithmic_ runtime. You will see this runtime in search algorithms.
-   **Θ(N)**. This is _linear_ runtime. You will often see this when you have to iterate through an entire dataset.
-   **Θ(N\*logN)**. You will see this runtime in sorting algorithms.
-   **Θ(N2)**. This is an example of a _polynomial_ runtime. When **N** is raised to the **2nd** power, it’s known as a _quadratic_ runtime. You will see this runtime when you have to search through a two-dimensional dataset (like a matrix) or nested loops.
-   **Θ(2N)**. This is _exponential_ runtime. You will often see this runtime in recursive algorithms (Don’t worry if you don’t know what that is yet!).
-   **Θ(N!)**. This is _factorial_ runtime. You will often see this runtime when you have to generate all of the different permutations of something. For instance, a program that generates all the different ways to order the letters “abcd” would run in this runtime.

Community Support

Still have questions? Get help from the [Codecademy community](https://community.codecademy.com/c/start-here/).

## Image

![runtimes](https://content.codecademy.com/programs/cs-path/asymptotic%20notation/conceptual/commonRuntimes.svg)

## Embedded Content

---

# Algorithmic Complexity | Codecademy

# Asymptotic Notation: Conceptual: Big Omega (Ω) and Big O (O)

## Narrative and Instructions

Learn

Asymptotic Notation: Conceptual

### Big Omega (Ω) and Big O (O)

6 min

Sometimes, a program may have a different

Preview: Docs Loading link description

[runtime](https://www.codecademy.com/resources/docs/general/runtime)

for the best case and worst case. For instance, a program could have a best case runtime of Θ(1) and a worst case of Θ(N). We use a different notation when this is the case. We use big Omega or Ω to describe the best case and big O or O to describe the worst case. Take a look at the following

Preview: Docs Loading link description

[pseudocode](https://www.codecademy.com/resources/docs/general/pseudocode)

that returns True if 12 is in the list and False otherwise:

```
Function with input that is a list of size N:    For each value in the list:        If value is equal to 12:            Return True    Return False
```

How many times will the loop iterate? Let’s take a list of size 1000. If the first value in the list was 12, then the loop would only iterate once. However, if 12 wasn’t in the list at all, the loop would iterate 1000 times. If the input was a list of size N, the loop could iterate anywhere from 1 to N times depending on where 12 is in the list (or if it’s in the list at all). Thus, in the best case, it has a constant runtime and in the worst case it has a linear runtime.

There are many ways we could describe the runtime of this program:

-   This program has a best case runtime of Θ(1).
-   This program has a worst case runtime of Θ(N).
-   This program has a runtime of Ω(1).
-   This program has a runtime O(N).

You may be tempted to say the following:

-   This program has a runtime of Θ(N).

However, this is not true because the program does not have a linear runtime in every case, only the worst case.

In fact, when describing runtime, people typically discuss the worst case because you should always prepare for the worst case scenario! **Often times, in technical interviews, they will only ask you for the big O of a program.**

Great! Now you know the different types of asymptotic notation and when to use which one! Now, let’s delve into more complex program runtimes!

Instructions

Play the video to go through an example of finding the big Omega and big O runtime of a function.

Community Support

Still have questions? Get help from the [Codecademy community](https://community.codecademy.com/c/start-here/).

## Video

<iframe frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" title="Big Omega and O" width="100%" height="100%" src="https://www.youtube.com/embed/EkDbukKyipU?autoplay=0&amp;mute=0&amp;controls=1&amp;origin=https%3A%2F%2Fwww.codecademy.com&amp;playsinline=1&amp;showinfo=0&amp;rel=0&amp;iv_load_policy=3&amp;modestbranding=1&amp;color=white&amp;enablejsapi=1&amp;widgetid=1&amp;forigin=https%3A%2F%2Fwww.codecademy.com%2Fpaths%2Fap-computer-science-a%2Ftracks%2Fapcs-algorithms%2Fmodules%2Fapcs-algorithmic-complexity%2Flessons%2Fasymptotic-notation-conceptual%2Fexercises%2Fbig-omega-o&amp;aoriginsup=1&amp;gporigin=https%3A%2F%2Fwww.codecademy.com%2Fpaths%2Fap-computer-science-a%2Ftracks%2Fapcs-algorithms%2Fmodules%2Fapcs-algorithmic-complexity%2Farticles%2Fcspath-why-asymptotic-notation&amp;vf=6" id="widget2"></iframe>

TODO： 需要观看视频并且整理内容。

这段视频讨论了如何找到具有多种情况的函数的运行时间，介绍了大 Ω 表示最佳情况而大 O 表示最坏情况，并强调通常需要用大 O 表示法描述运行时间，因为我们总是关注最坏情况。
Detailed Summary for [Big Omega and O

不公开](https://www.youtube.com/watch?v=EkDbukKyipU) by [Monica](https://monica.im)

[00:00](https://www.youtube.com/watch?v=EkDbukKyipU&t=0) 本视频讨论了如何计算具有多种情况的函数的运行时间，特别是通过分析循环的迭代次数来理解不同输入大小对运行时间的影响。

-   引入视频主题，介绍将要讨论的内容。}
-   以一个检查列表中是否存在特定值的函数为例，说明函数运行的基本逻辑。}
-   强调在有循环的函数中，需要根据输入大小来计算循环的迭代次数。}
-   介绍两种边界情况，并探讨这些情况如何影响函数的运行时间。}
-   通过具体例子说明，当目标值在列表中时，函数的迭代次数会减少。}

[01:20](https://www.youtube.com/watch?v=EkDbukKyipU&t=80.07) 本视频探讨了在不同情况下检查列表中是否包含特定值（如 12）的运行时间复杂度，特别是如何通过优化算法实现更高效的查找。

-   介绍了在列表中查找特定值所需的循环次数，强调了需要逐一检查每个值。}
-   讨论了当 n 为 100 和 1000 时的不同情况，指出如果第一个值是 12，则只需进行一次循环。}
-   分析了最佳情况的运行时间复杂度，强调当第一个值为 12 时，列表的大小对循环次数没有影响。}
-   总结了在最佳情况下，算法的运行效率更高，因为计算机只需执行一次循环。}

[02:40](https://www.youtube.com/watch?v=EkDbukKyipU&t=160.77) 本视频介绍了大 Ω 和大 O 符号在算法运行时间分析中的应用，重点是最佳情况和最坏情况的描述方法。

-   使用大 Ω 符号描述算法的运行时间，表示最佳情况的常量运行时间。}
-   使用大 O 符号描述算法的运行时间，表示最坏情况下的线性运行时间。}
-   总结了函数在分析运行时间时的两种情况：最佳情况和最坏情况，以及如何通过迭代次数来进行分析。}

## Embedded Content

---

# Algorithmic Complexity | Codecademy

# Asymptotic Notation: Conceptual: Adding Runtimes

## Narrative and Instructions

Learn

Asymptotic Notation: Conceptual

### Adding Runtimes

3 min

Sometimes, a program has so much going on that it’s hard to find the

Preview: Docs Loading link description

[runtime](https://www.codecademy.com/resources/docs/general/runtime)

of it. Take a look at the

Preview: Docs Loading link description

[pseudocode](https://www.codecademy.com/resources/docs/general/pseudocode)

program that first prints all the positive values up to N and then returns the number of times it takes to divide N by 2 until N is 1.

```
Function that takes a positive integer N:    Set a variable i equal to 1    Loop until i is equal to N:        Print i        Increment i        Set a count variable to 0    Loop while N is not equal to 1:        Increment count        N = N/2    Return count
```

Rather than look at this program all at once, let’s divide into two chunks: the first loop and the second loop.

-   In the first loop, we iterate until we reach N. Thus the runtime of the first loop is Θ(N).
-   However, the second loop, as demonstrated in a previous exercise, runs in Θ(log N).

Now, we can add the runtimes together, so the runtime is Θ(N) + Θ(log N).

However, when analyzing the runtime of a program, we only care about the slowest part of the program, and because Θ(N) is slower than Θ(log N), we would actually just say the runtime of this program is Θ(N). **It is also appropriate to say the runtime is O(N) because if it runs in Θ(N) for every case, then it also runs in Θ(N) for the worst case. Most of the time people will just use big O notation.**

Instructions

Play the video to go through an example of adding runtimes.

Community Support

Still have questions? Get help from the [Codecademy community](https://community.codecademy.com/c/start-here/).

## Video

<iframe frameborder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" title="Adding Runtimes" width="100%" height="100%" src="https://www.youtube.com/embed/07U1hAJB-Qg?autoplay=0&amp;mute=0&amp;controls=1&amp;origin=https%3A%2F%2Fwww.codecademy.com&amp;playsinline=1&amp;showinfo=0&amp;rel=0&amp;iv_load_policy=3&amp;modestbranding=1&amp;color=white&amp;enablejsapi=1&amp;widgetid=3&amp;forigin=https%3A%2F%2Fwww.codecademy.com%2Fpaths%2Fap-computer-science-a%2Ftracks%2Fapcs-algorithms%2Fmodules%2Fapcs-algorithmic-complexity%2Flessons%2Fasymptotic-notation-conceptual%2Fexercises%2Fadding-runtimes&amp;aoriginsup=1&amp;gporigin=https%3A%2F%2Fwww.codecademy.com%2Fpaths%2Fap-computer-science-a%2Ftracks%2Fapcs-algorithms%2Fmodules%2Fapcs-algorithmic-complexity%2Farticles%2Fcspath-why-asymptotic-notation&amp;vf=6" id="widget4"></iframe>

TODO： 需要观看视频并且整理内容。

在这个视频中，我们讨论了如何为复杂函数添加运行时间，通过将函数分成多个部分来计算各自的运行时间，并通过添加这些运行时间找出主导项，最终简化整体运行时间为 Theta N。
Detailed Summary for [Adding Runtimes

不公开](https://www.youtube.com/watch?v=07U1hAJB-Qg) by [Monica](https://monica.im)

[00:00](https://www.youtube.com/watch?v=07U1hAJB-Qg&t=0.68) 本视频讨论了如何分析和计算函数的运行时间，特别是在函数包含多个操作时的处理方法。

-   视频介绍了讨论的主题，即添加运行时间的计算。}
-   以一个函数为例，该函数接受一个正整数 n，并包含两个循环。}
-   讲解了如何将复杂函数的运行时间分解为多个部分，以便更好地分析。}
-   第一个循环的运行时间是线性的，因为需要遍历从 0 到 n 的每一个值。}
-   探讨了第二个循环的运行时间，并与大 Θ 符号相关联。}

[00:55](https://www.youtube.com/watch?v=07U1hAJB-Qg&t=55.68) 本视频讲解了如何计算函数的整体运行时间，强调了主导项的重要性。

-   介绍了如何找到函数的整体运行时间，并提到分开计算不同部分的运行时间。}
-   解释了在大 O 符号中，主导项的选择对于简化运行时间的重要性。}
-   总结了通过将函数分解为多个部分，计算各自的运行时间并选择主导项的过程。}

## Embedded Content

---

# Algorithmic Complexity | Codecademy

# Asymptotic Notation: Conceptual: Review

## Narrative and Instructions

Learn

Asymptotic Notation: Conceptual

### Review

1 min

Let’s review what we learned:

-   We use asymptotic notation to describe the runtime of a program. The three types of asymptotic notation are big Theta, big Omega, and big O.
-   We use big Theta (Θ) to describe the runtime if the runtime of the program is the same in every case.
-   The different common runtimes from fastest to slowest are: Θ(1), Θ(log N), Θ(N), Θ(N log N), Θ(N2), Θ(2N), Θ(N!).
-   We use big Omega (Ω) to describe the best-case running time of a program.
-   We use big O (O) to describe the worst-case running time of a program.
-   **We typically describe a program’s running time in terms of big O.**
-   When finding the runtime of a program with multiple steps, you can divide the program into different sections and add the runtimes of the various sections. You can then take the slowest runtime and use that runtime to describe the entire program.
-   When analyzing the runtime of a program, we care about which part of the program is the slowest.

Now that we conceptually understand what asymptotic notation is, let’s practice analyzing and improving runtimes with real programming language examples!

Community Support

Still have questions? Get help from the [Codecademy community](https://community.codecademy.com/c/start-here/).

## Image

![diagrams of common runtimes](https://content.codecademy.com/programs/cs-path/asymptotic-notation/commonRuntimes.svg)

## Embedded Content

---
